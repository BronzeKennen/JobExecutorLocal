# JobExecutor
Σωτήριος Σκανδάλης
1115202000181

## Γενικα
Στην εργασία αυτή χρησιμοποιώ 2 FIFOs (ενα commander -> server, και ενα server -> commander) για την επικοινωνία  όσο και ως προς τον συγχρονισμό μεταξύ τους. Πιο συγκεκριμένα τα προγραμματα ανοίγουν τα pipes με blocking enabled ώστε να περιμένουν
"ανταπόκριση" το ένα απο το άλλο πρωτού συνεχίσουν στην επικοινωνία.
O jobCommander δεν χρησιμοποιει κανένα είδους user signal για να ενεργοποιήσει τον server να εξυπηρετήσει. Ο μηχανισμός επικοινωνίας μεταξύ τους είναι σεμαφόροι και διαμοιραζόμενη μνήμη. Ο λόγος είναι πως δεν βοηθούσε η διαχείρηση signals οπου στην περιπτωση που πρόκειται να σταλθούν πολλαπλά signals μαζί, ο handler θα ενεργοποιούταν μόνο για 1. Με τον σεμαοφόρο όμως δεν ισχυεί καθώς κάθε command του commander είναι και ενα sem_up στον σεμαφορο. Η διαμοιραζόμενη μνήμη επίσης βοήθησε στο να έχουν επικοινωνία τα προγράμματα και να ξέρουν πόσα bytes πρέπει να διαβάσουν. Έτσι ο server μπορεί να διαβάσει οσαδήποτε bytes χρειάζεται και δεν έχω σταθερού μήκους buffers. 

Για να ξεκινήσει η διαδικασία εξυπηρέτησης ο commander σιγουρεύεται πρώτα ότι ο server έχει ξεκινήσει και οτι μπορεί να διαβάσει το pid απο το αρχείο, αλλιώς δεν προχωράει στο υπόλοιπο πρόγραμμα. Αν ο server δεν έχει ξεκινήσει, ο commander κάνει fork και τρέχει τον server με execvp. Στο .txt αρχείο γράφεται επίσης στην δεύτερη γραμμή το shared memory segment id για να μπορέσει να κάνει attach ο commander. 

## Επικοινωνία
Αφού έχει περάσει η διαδικασία αρχικοποίησης και εκκίνησησς του server (αν χρειάζεται) ο commander κάνει parse την εντολή και τα τυχόν arguments που έχει. Μετράει το μέγεθος των arguments και ενημερώνει τον server σε μια shared μεταβλητή το μέγεθος το οποιο πρόκειται να μεταφέρει, αυξανει το σεμαφορο κατα 1 για να ενεργοποιηθει ο server και τα αποστέλει στο pipe. Αν η εντολή χρειάζεται αναμονή απάντησης (π.χ. τριπλέτα σε issueJob) ανοίγει το άλλο pipe και περιμένει ο server να στείλει απάντηση. 

## Δομες
Ο server χρησιμοποιει linked lists (στο προγραμμα γραφεται pQueue αλλα κατεληξε τελικα να ειναι πολυ περισσότερο λίστα παρα Queue) και χρησιμοποιέι 2 λιστες, μια για τα jobs που ειναι σε αναμονή (queued) και μία για τα jobs που τρέχουν εκείνη την στιγμή (running). Οι λιστες έχουν ανάλογες μεθόδους (insert,remove,remove first,find etc) για να μπορέσουν να πετύχουν το αποτέλεσμα για τη λειτουργία της ουράς αναμονής του server.
Ο server χρησιμοποιει επίσης 2 structs. Τα running jobs έχουν διαφορετικά attributes σε σχέση με αυτά που έιναι στην ουρά. Πιο συγκεκριμένα:

Queued:
  jobId (το id που αναθέτει ο server)
  job (Η ίδια η εντολή)
  queue number

Running:
  jobId (το id που αναθέτει ο server)
  pid (process id)

Οι διεργασιίες που τρέχουν δεν έχουν queue number και δεν χρειάζονται το χαρακτηριστικό job εφόσον ήδη έχουν εκτελεστεί. Χρειάζονται όμως το jobId (για να λειτουργεί η stop) και χρειάζονται και το pid για να μπορώ να διαχειριστώ το τέλος της διεργασίας ώστε να τρέξω μία άλλη στην θέση της με waitpid. H τριπλέτα του queued struct επιστρέφεται και στον commander όταν γίνει ανάθεση.

## Παραλληλία και διεργασίες

Ο τρόπος που μια διεργασία περνάει από έλεγχο ώστε να τρέξει είναι απο την συνάρτηση execution_check. Η συνάρτηση αυτή καλέιται μετά από κάποια αλλαγή η οποία θα μπορούσε να αλλάξει ποιες διεργασίες τρέχουν η θα τρέξουν. (πχ. μετα απο issueJob,stop,τέλος child process,αλλαγή concurrency). Η execution_check ξέρει συνεχώς το concurrency και το πόσες διεργασίες τρέχουν. Αν υπάρχουν λιγότερες running από όσες είναι επιτρεπτό να τρέξουν, παίρνει την πρώτη διεργασία απο την queued την εισάγει στις running και κανει fork-exec την ίδια την εντολή (πεδίο job). Ταυτόχρονα, το πρόγραμμα ενημερώνεται συνεχώς αν μία διεργασία τελειώσε καλώντας συνεχώς waitpid. Αν η waitpid δεν επιστρέψει -1, σημαίνει ότι κάποια διεργασία τελείωσε. Τότε αφαιρούμε απο τις running την διεργασία που τελείωσε με βάση το pid που επέστρεψε η waitpid μειώνουμε κατα 1 τις running διεργασίες, και ξανακαλούμε την execution_check για να τρέξει η επόμενη διεργασία που περιμένει στην ουρά (αν υπάρχει διεργασία που περιμένει).

## Bash scripts

### multijob.sh
Διαβάζει ενα αρχέιο και για κάθε γραμμή που διαβάζει κάνει echo αυτο που διάβασε και μπροστά προσθέτει ./jobCommander issueJob. That's it.

### allJobsStop.sh
Τρέχει πρώτα poll queued, αν δεν επιστρέψει η εντολη no jobs to print, διαβάζει κάθε γραμμή που επέστρεψε η εντολή, κόβει τη γραμμή στο "," και αυτό αφήνει μόνο το jobId. Κρατάω το jobId και τρέχω ./jobCommander stop jobId, το ίδιο κάνω μετά αλλα με poll running.

## Bugs
Όταν κάνω job stop σε running διεργασία, ενώ τρέχει κανονικά η επόμενη συγκεκριμένα όταν κάνω kill child γίνεται corrupted μέσα στη λίστα η πρώτη διεγασία από τις queued. Ενω τρέχει κανονικά και μπορώ να διαβάσω τα περιεχόμενα όταν πάω να την εισάγω στις running η διεργασία αυτή γίνεται corrupted, και δεν φαινεται στην poll.

